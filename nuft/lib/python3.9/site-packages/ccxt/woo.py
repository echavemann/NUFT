# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import hashlib
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import RateLimitExceeded
from ccxt.base.decimal_to_precision import TICK_SIZE
from ccxt.base.precise import Precise


class woo(Exchange):

    def describe(self):
        return self.deep_extend(super(woo, self).describe(), {
            'id': 'woo',
            'name': 'WOO X',
            'countries': ['KY'],  # Cayman Islands
            'rateLimit': 100,
            'version': 'v1',
            'certified': False,
            'hostname': 'woo.org',
            'has': {
                'CORS': None,
                'spot': True,
                'margin': True,
                'swap': False,
                'future': False,
                'option': False,
                'cancelAllOrders': False,
                'cancelOrder': True,
                'cancelOrders': True,
                'cancelWithdraw': False,  # exchange have that endpoint disabled atm, but was once implemented in ccxt per old docs: https://kronosresearch.github.io/wootrade-documents/#cancel-withdraw-request
                'createMarketOrder': False,
                'createOrder': True,
                'fetchBalance': True,
                'fetchCanceledOrders': False,
                'fetchClosedOrder': False,
                'fetchClosedOrders': False,
                'fetchCurrencies': True,
                'fetchDepositAddress': False,
                'fetchDeposits': True,
                'fetchFundingHistory': False,
                'fetchFundingRate': False,
                'fetchFundingRateHistory': False,
                'fetchFundingRates': False,
                'fetchIndexOHLCV': False,
                'fetchLedger': True,
                'fetchMarkets': True,
                'fetchMarkOHLCV': False,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenOrder': False,
                'fetchOpenOrders': False,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrders': True,
                'fetchOrderTrades': True,
                'fetchPremiumIndexOHLCV': False,
                'fetchStatus': False,
                'fetchTicker': False,
                'fetchTickers': False,
                'fetchTime': False,
                'fetchTrades': True,
                'fetchTradingFee': False,
                'fetchTradingFees': True,
                'fetchTransactions': True,
                'fetchTransfers': True,
                'fetchWithdrawals': True,
                'transfer': True,
                'withdraw': False,  # exchange have that endpoint disabled atm, but was once implemented in ccxt per old docs: https://kronosresearch.github.io/wootrade-documents/#token-withdraw
            },
            'timeframes': {
                '1m': '1m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '4h': '4h',
                '12h': '12h',
                '1d': '1d',
                '1w': '1w',
                '1M': '1mon',
                '1y': '1y',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/150730761-1a00e5e0-d28c-480f-9e65-089ce3e6ef3b.jpg',
                'api': {
                    'public': 'https://api.{hostname}',
                    'private': 'https://api.{hostname}',
                },
                # TEST(stating) api( https://support.woo.org/hc/en-001/articles/4406352945305--Institutional-Account-Welcome-Packet-V-2) doesn't work at self moment, even thou
                # 'test': {
                #     'public': 'http://api.staging.woo.org',
                #     'private': 'http://api.staging.woo.org',
                # },
                'www': 'https://woo.org/',
                'doc': [
                    'https://docs.woo.org/',
                ],
                'fees': [
                    'https://support.woo.org/hc/en-001/articles/4404611795353--Trading-Fees',
                ],
                'referral': 'https://referral.woo.org/BAJS6oNmZb3vi3RGA',
            },
            'api': {
                'v1': {
                    'public': {
                        'get': {
                            'info': 1,
                            'info/{symbol}': 1,
                            'market_trades': 1,
                            'token': 1,
                            'token_network': 1,
                        },
                    },
                    'private': {
                        'get': {
                            'client/token': 1,
                            'order/{oid}': 1,
                            'client/order/{client_order_id}': 1,
                            'orders': 1,
                            'orderbook/{symbol}': 1,
                            'kline': 1,
                            'client/trade/{tid}': 1,
                            'order/{oid}/trades': 1,
                            'client/trades': 1,
                            'client/info': 60,
                            'asset/deposit': 120,
                            'asset/history': 60,
                            'token_interest': 60,
                            'token_interest/{token}': 60,
                            'interest/history': 60,
                            'interest/repay': 60,
                        },
                        'post': {
                            'order': 5,  # 2 requests per 1 second per symbol
                            'asset/main_sub_transfer': 30,  # 20 requests per 60 seconds
                            'asset/withdraw': 120,  # implemented in ccxt, disabled on the exchange side https://kronosresearch.github.io/wootrade-documents/#token-withdraw
                        },
                        'delete': {
                            'order': 1,
                            'client/order': 1,
                            'orders': 1,
                            'asset/withdraw': 120,  # implemented in ccxt, disabled on the exchange side https://kronosresearch.github.io/wootrade-documents/#cancel-withdraw-request
                        },
                    },
                },
                'v2': {
                    'private': {
                        'get': {
                            'client/holding': 1,
                        },
                    },
                },
            },
            'fees': {
                'trading': {
                    'tierBased': True,
                    'percentage': True,
                    'maker': self.parse_number('0.0002'),
                    'taker': self.parse_number('0.0005'),
                },
            },
            'options': {
                'createMarketBuyOrderRequiresPrice': True,
                'network-aliases': {
                    'ALGO': 'ALGO',
                    'ATOM': 'ATOM',
                    'AVAXC': 'AVAXC',
                    'BNB': 'BEP2',
                    'BSC': 'BEP20',
                    'BTC': 'BTC',
                    'BCHSV': 'BSV',
                    'EOS': 'EOS',
                    'ETH': 'ERC20',
                    'HECO': 'HRC20',
                    'MATIC': 'POLYGON',
                    'ONT': 'ONT',
                    'SOL': 'SPL',
                    'TERRA': 'TERRA',
                    'TRON': 'TRC20',
                },
                # network-aliases for titles are removed(just in case, if needed: pastebin.com/raw/BvgKViPN )
                'network-aliases-for-protocol': {
                    'ALGO': 'ALGO',
                    'ATOM': 'ATOM',
                    'C Chain': 'AVAXC',
                    'BEP2': 'BEP2',
                    'BEP20': 'BEP20',
                    'BTC': 'BTC',
                    'BSV': 'BSV',
                    'EOS': 'EOS',
                    'ERC20': 'ERC20',
                    'HECO': 'HRC20',
                    'Polygon': 'POLYGON',
                    'ONT': 'ONT',
                    'SOL': 'SPL',
                    'TERRA': 'TERRA',
                    'TRON': 'TRC20',
                },
                # these network aliases require manual mapping here
                'network-aliases-for-tokens': {
                    'HT': 'ERC20',
                    'OMG': 'ERC20',
                    'UATOM': 'ATOM',
                    'ZRX': 'ZRX',
                },
                'defaultNetworkCodePriorities': [
                    'TRC20',
                    'ERC20',
                    'BSC20',
                ],
                # override defaultNetworkCodePriorities for a specific currency
                'defaultNetworkCodeForCurrencies': {
                    # 'USDT': 'TRC20',
                    # 'BTC': 'BTC',
                },
                'transfer': {
                    'fillResponseFromRequest': True,
                },
            },
            'commonCurrencies': {},
            'exceptions': {
                'exact': {
                    '-1000': ExchangeError,  # {"code": -1000,  "message": "An unknown error occurred while processing the request"}
                    '-1001': AuthenticationError,  # {"code": -1001,  "message": "The api key or secret is in wrong format"}
                    '-1002': AuthenticationError,  # {"code": -1002,  "message": "API key or secret is invalid, it may because key have insufficient permission or the key is expired/revoked."}
                    '-1003': RateLimitExceeded,  # {"code": -1003,  "message": "Rate limit exceed."}
                    '-1004': BadRequest,  # {"code": -1004,  "message": "An unknown parameter was sent."}
                    '-1005': BadRequest,  # {"code": -1005,  "message": "Some parameters are in wrong format for api."}
                    '-1006': BadRequest,  # {"code": -1006,  "message": "The data is not found in server."}
                    '-1007': BadRequest,  # {"code": -1007,  "message": "The data is already exists or your request is duplicated."}
                    '-1008': InvalidOrder,  # {"code": -1008,  "message": "The quantity of settlement is too high than you can request."}
                    '-1009': BadRequest,  # {"code": -1009,  "message": "Can not request withdrawal settlement, you need to deposit other arrears first."}
                    '-1011': ExchangeError,  # {"code": -1011,  "message": "Can not place/cancel orders, it may because internal network error. Please try again in a few seconds."}
                    '-1012': BadRequest,  # {"code": -1012,  "message": "Amount is required for buy market orders when margin disabled."}  The place/cancel order request is rejected by internal module, it may because the account is in liquidation or other internal errors. Please try again in a few seconds."}
                    '-1101': InvalidOrder,  # {"code": -1101,  "message": "The risk exposure for client is too high, it may cause by sending too big order or the leverage is too low. please refer to client info to check the current exposure."}
                    '-1102': InvalidOrder,  # {"code": -1102,  "message": "The order value(price * size) is too small."}
                    '-1103': InvalidOrder,  # {"code": -1103,  "message": "The order price is not following the tick size rule for the symbol."}
                    '-1104': InvalidOrder,  # {"code": -1104,  "message": "The order quantity is not following the step size rule for the symbol."}
                    '-1105': InvalidOrder,  # {"code": -1105,  "message": "Price is X% too high or X% too low from the mid price."}
                },
                'broad': {
                    'symbol must not be blank': BadRequest,  # when sending 'cancelOrder' without symbol [-1005]
                    'The token is not supported': BadRequest,  # when getting incorrect token's deposit address [-1005]
                    'Your order and symbol are not valid or already canceled': BadRequest,  # actual response whensending 'cancelOrder' for already canceled id [-1006]
                    'Insufficient WOO. Please enable margin trading for leverage trading': BadRequest,  # when selling insufficent token [-1012]
                },
            },
            'precisionMode': TICK_SIZE,
        })

    def fetch_markets(self, params={}):
        marketType, query = self.handle_market_type_and_params('fetchMarkets', None, params)
        method = self.get_supported_mapping(marketType, {
            'spot': 'v1PublicGetInfo',
        })
        response = getattr(self, method)(query)
        #
        # {
        #     rows: [
        #         {
        #             symbol: "SPOT_AAVE_USDT",
        #             quote_min: 0,
        #             quote_max: 100000,
        #             quote_tick: 0.01,
        #             base_min: 0.01,
        #             base_max: 7284,
        #             base_tick: 0.0001,
        #             min_notional: 10,
        #             price_range: 0.1,
        #             created_time: "0",
        #             updated_time: "1639107647.988",
        #             is_stable: 0
        #         },
        #         ...
        #     success: True
        # }
        #
        data = self.safe_value(response, 'rows', [])
        result = []
        for i in range(0, len(data)):
            market = data[i]
            marketId = self.safe_string(market, 'symbol')
            parts = marketId.split('_')
            marketTypeVal = self.safe_string_lower(parts, 0)
            isSpot = marketTypeVal == 'spot'
            isSwap = False
            isFuture = False
            isOption = False
            baseId = self.safe_string(parts, 1)
            quoteId = self.safe_string(parts, 2)
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            symbol = base + '/' + quote
            minQuote = self.safe_number(market, 'quote_min')
            maxQuote = self.safe_number(market, 'quote_max')
            minBase = self.safe_number(market, 'base_min')
            maxBase = self.safe_number(market, 'base_max')
            priceScale = self.safe_number(market, 'quote_tick')
            quantityScale = self.safe_number(market, 'base_tick')
            minCost = self.safe_number(market, 'min_notional')
            result.append({
                'id': marketId,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'settle': None,
                'baseId': baseId,
                'quoteId': quoteId,
                'settleId': None,
                'type': marketTypeVal,
                'spot': isSpot,
                'margin': True,
                'swap': False,
                'future': False,
                'option': False,
                'active': None,
                'contract': isSwap or isFuture or isOption,
                'linear': None,
                'inverse': None,
                'contractSize': None,
                'expiry': None,
                'expiryDatetime': None,
                'strike': None,
                'optionType': None,
                'precision': {
                    'amount': quantityScale,
                    'price': priceScale,
                },
                'limits': {
                    'leverage': {
                        'min': None,
                        'max': None,
                    },
                    'amount': {
                        'min': minBase,
                        'max': maxBase,
                    },
                    'price': {
                        'min': minQuote,
                        'max': maxQuote,
                    },
                    'cost': {
                        'min': minCost,
                        'max': None,
                    },
                },
                'info': market,
            })
        return result

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchTrades() requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['limit'] = limit
        marketType, query = self.handle_market_type_and_params('fetchTrades', market, params)
        method = self.get_supported_mapping(marketType, {
            'spot': 'v1PublicGetMarketTrades',
        })
        response = getattr(self, method)(self.extend(request, query))
        #
        # {
        #     success: True,
        #     rows: [
        #         {
        #             symbol: "SPOT_BTC_USDT",
        #             side: "SELL",
        #             executed_price: 46222.35,
        #             executed_quantity: 0.0012,
        #             executed_timestamp: "1641241162.329"
        #         },
        #         {
        #             symbol: "SPOT_BTC_USDT",
        #             side: "SELL",
        #             executed_price: 46222.35,
        #             executed_quantity: 0.0012,
        #             executed_timestamp: "1641241162.329"
        #         },
        #         {
        #             symbol: "SPOT_BTC_USDT",
        #             side: "BUY",
        #             executed_price: 46224.32,
        #             executed_quantity: 0.00039,
        #             executed_timestamp: "1641241162.287"
        #         },
        #         ...
        #      ]
        # }
        #
        resultResponse = self.safe_value(response, 'rows', {})
        return self.parse_trades(resultResponse, market, since, limit)

    def parse_trade(self, trade, market=None):
        #
        # public/market_trades
        #
        #     {
        #         symbol: "SPOT_BTC_USDT",
        #         side: "SELL",
        #         executed_price: 46222.35,
        #         executed_quantity: 0.0012,
        #         executed_timestamp: "1641241162.329"
        #     }
        #
        # fetchOrderTrades, fetchOrder
        #
        #     {
        #         id: '99119876',
        #         symbol: 'SPOT_WOO_USDT',
        #         fee: '0.0024',
        #         side: 'BUY',
        #         executed_timestamp: '1641481113.084',
        #         order_id: '87001234',
        #         order_tag: 'default', <-- self param only in "fetchOrderTrades"
        #         executed_price: '1',
        #         executed_quantity: '12',
        #         fee_asset: 'WOO',
        #         is_maker: '1'
        #     }
        #
        isFromFetchOrder = ('id' in trade)
        timestamp = self.safe_timestamp(trade, 'executed_timestamp')
        marketId = self.safe_string(trade, 'symbol')
        market = self.safe_market(marketId, market)
        symbol = market['symbol']
        price = self.safe_string(trade, 'executed_price')
        amount = self.safe_string(trade, 'executed_quantity')
        order_id = self.safe_string(trade, 'order_id')
        fee = self.parse_token_and_fee_temp(trade, 'fee_asset', 'fee')
        cost = Precise.string_mul(price, amount)
        side = self.safe_string_lower(trade, 'side')
        id = self.safe_string(trade, 'id')
        if id is None:  # reconstruct artificially, if it doesn't exist
            if timestamp is not None:
                amountStr = '' if (amount is None) else amount
                sideStr = '' if (side is None) else side
                priceStr = '' if (price is None) else price
                marketIdStr = self.safe_string(market, 'id', '')
                id = self.number_to_string(timestamp) + '-' + marketIdStr + '-' + sideStr + '-' + amountStr + '-' + priceStr
        takerOrMaker = None
        if isFromFetchOrder:
            isMaker = self.safe_string(trade, 'is_maker') == '1'
            takerOrMaker = 'maker' if isMaker else 'taker'
        return self.safe_trade({
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'order': order_id,
            'takerOrMaker': takerOrMaker,
            'type': None,
            'fee': fee,
            'info': trade,
        }, market)

    def parse_token_and_fee_temp(self, item, feeTokenKey, feeAmountKey):
        feeCost = self.safe_string(item, feeAmountKey)
        fee = None
        if feeCost is not None:
            feeCurrencyId = self.safe_string(item, feeTokenKey)
            feeCurrencyCode = self.safe_currency_code(feeCurrencyId)
            fee = {
                'cost': feeCost,
                'currency': feeCurrencyCode,
            }
        return fee

    def fetch_trading_fees(self, params={}):
        self.load_markets()
        response = self.v1PrivateGetClientInfo(params)
        #
        #     {
        #         "application":{
        #             "id":45585,
        #             "leverage":3.00,
        #             "otpauth":false,
        #             "alias":"email@address.com",
        #             "application_id":"c2cc4d74-c8cb-4e10-84db-af2089b8c68a",
        #             "account":"email@address.com",
        #             "account_mode":"PURE_SPOT",
        #             "taker_fee_rate":5.00,
        #             "maker_fee_rate":2.00,
        #             "interest_rate":0.00,
        #             "futures_leverage":1.00,
        #             "futures_taker_fee_rate":5.00,
        #             "futures_maker_fee_rate":2.00
        #         },
        #         "margin_rate":1000,
        #         "success":true
        #     }
        #
        application = self.safe_value(response, 'application', {})
        maker = self.safe_string(application, 'maker_fee_rate')
        taker = self.safe_string(application, 'taker_fee_rate')
        result = {}
        for i in range(0, len(self.symbols)):
            symbol = self.symbols[i]
            result[symbol] = {
                'info': response,
                'symbol': symbol,
                'maker': self.parse_number(Precise.string_div(maker, '10000')),
                'taker': self.parse_number(Precise.string_div(taker, '10000')),
                'percentage': True,
                'tierBased': True,
            }
        return result

    def fetch_currencies(self, params={}):
        method = None
        result = {}
        marketType, query = self.handle_market_type_and_params('fetchCurrencies', None, params)
        method = self.get_supported_mapping(marketType, {
            'spot': 'v1PublicGetToken',
        })
        tokenResponse = getattr(self, method)(query)
        #
        # {
        #     rows: [
        #         {
        #             token: "ETH_USDT",
        #             fullname: "Tether",
        #             decimals: 6,
        #             balance_token: "USDT",
        #             created_time: "0",
        #             updated_time: "0"
        #         },
        #         {
        #             token: "BSC_USDT",
        #             fullname: "Tether",
        #             decimals: 18,
        #             balance_token: "USDT",
        #             created_time: "0",
        #             updated_time: "0"
        #         },
        #         {
        #             token: "ZEC",
        #             fullname: "ZCash",
        #             decimals: 8,
        #             balance_token: "ZEC",
        #             created_time: "0",
        #             updated_time: "0"
        #         },
        #         ...
        #     ],
        #     success: True
        # }
        #
        method = self.get_supported_mapping(marketType, {
            'spot': 'v1PublicGetTokenNetwork',
        })
        tokenNetworkResponse = getattr(self, method)(query)
        #
        # {
        #     rows: [
        #         {
        #             protocol: "ERC20",
        #             token: "USDT",
        #             name: "Ethereum",
        #             minimum_withdrawal: 30,
        #             withdrawal_fee: 25,
        #             allow_deposit: 1,
        #             allow_withdraw: 1
        #         },
        #         {
        #             protocol: "TRC20",
        #             token: "USDT",
        #             name: "Tron",
        #             minimum_withdrawal: 30,
        #             withdrawal_fee: 1,
        #             allow_deposit: 1,
        #             allow_withdraw: 1
        #         },
        #         ...
        #     ],
        #     success: True
        # }
        #
        tokenRows = self.safe_value(tokenResponse, 'rows', [])
        tokenNetworkRows = self.safe_value(tokenNetworkResponse, 'rows', [])
        networksByCurrencyId = self.group_by(tokenNetworkRows, 'token')
        for i in range(0, len(tokenRows)):
            currency = tokenRows[i]
            id = self.safe_string(currency, 'balance_token')
            code = self.safe_currency_code(id)
            name = self.safe_string(currency, 'fullname')
            decimals = self.safe_integer(currency, 'decimals')
            chainedTokenCode = self.safe_string(currency, 'token')
            parts = chainedTokenCode.split('_')
            chainNameId = self.safe_string(parts, 0, chainedTokenCode)
            chainCode = self.safe_string(self.options['network-aliases'], chainNameId, chainNameId)
            if not (code in result):
                networks = self.safe_value(networksByCurrencyId, id, [])
                resultingNetworks = {}
                for j in range(0, len(networks)):
                    networkEntry = networks[j]
                    networkId = self.safe_string(networkEntry, 'protocol')
                    networkIdManualMatched = self.safe_string(self.options['network-aliases-for-tokens'], networkId, networkId)
                    networkCode = self.safe_string_2(self.options['network-aliases-for-protocol'], chainNameId, chainNameId, networkIdManualMatched)
                    depositEnabled = self.safe_integer(networkEntry, 'allow_deposit', 0)
                    withdrawEnabled = self.safe_integer(networkEntry, 'allow_withdraw', 0)
                    resultingNetworks[networkCode] = {
                        'id': networkId,
                        'network': networkCode,
                        'limits': {
                            'withdraw': {
                                'min': self.safe_number(networkEntry, 'minimum_withdrawal'),
                                'max': None,
                            },
                            'deposit': {
                                'min': None,
                                'max': None,
                            },
                        },
                        'active': None,
                        'deposit': depositEnabled,
                        'withdraw': withdrawEnabled,
                        'fee': self.safe_number(networkEntry, 'withdrawal_fee'),
                        'precision': None,  # will be filled down below
                        'info': networkEntry,
                    }
                networksKeys = list(resultingNetworks.keys())
                firstNetworkKey = networksKeys[0]
                networkLength = len(networksKeys)
                result[code] = {
                    'id': id,
                    'name': name,
                    'code': code,
                    'precision': decimals if (networkLength == 1) else None,  # will be filled down below
                    'active': None,
                    'fee': resultingNetworks[firstNetworkKey]['fee'] if (networkLength == 1) else None,
                    'networks': resultingNetworks,
                    'limits': {
                        'deposit': {
                            'min': None,
                            'max': None,
                        },
                        'withdraw': {
                            'min': resultingNetworks[firstNetworkKey]['limits']['withdraw']['min'] if (networkLength == 1) else None,
                            'max': None,
                        },
                    },
                    'info': {},  # will be filled down below
                }
            networkKeys = list(result[code]['networks'].keys())
            firstNetworkKey = self.safe_string(networkKeys, 0)
            # now add the precision info from token-object
            if chainCode in result[code]['networks']:
                result[code]['networks'][chainCode]['precision'] = decimals
            else:
                # else chainCode will be the only token slug, which has only 1 supported network
                result[code]['networks'][firstNetworkKey]['precision'] = decimals
            # now add the info object specifically for the item
            result[code]['info'][chainedTokenCode] = currency
        return result

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'order_type': type.upper(),
            'side': side.upper(),
        }
        if price is not None:
            request['order_price'] = self.price_to_precision(symbol, price)
        if type == 'market':
            # for market buy it requires the amount of quote currency to spend
            if side == 'buy':
                cost = self.safe_number(params, 'cost')
                if self.safe_value(self.options, 'createMarketBuyOrderRequiresPrice', True):
                    if cost is None:
                        if price is None:
                            raise InvalidOrder(self.id + " createOrder() requires the price argument for market buy orders to calculate total order cost. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or alternatively, supply the total cost value in the 'order_amount' in  exchange-specific parameters")
                        else:
                            request['order_amount'] = self.cost_to_precision(symbol, amount * price)
                    else:
                        request['order_amount'] = self.cost_to_precision(symbol, cost)
            else:
                request['order_quantity'] = self.amount_to_precision(symbol, amount)
        else:
            request['order_quantity'] = self.amount_to_precision(symbol, amount)
        clientOrderId = self.safe_string_2(params, 'clOrdID', 'clientOrderId')
        if clientOrderId is not None:
            request['client_order_id'] = clientOrderId
        params = self.omit(params, ['clOrdID', 'clientOrderId'])
        marketType, query = self.handle_market_type_and_params('createOrder', market, params)
        method = self.get_supported_mapping(marketType, {
            'spot': 'v1PrivatePostOrder',
        })
        response = getattr(self, method)(self.extend(request, query))
        # {
        #     success: True,
        #     timestamp: '1641383206.489',
        #     order_id: '86980774',
        #     order_type: 'LIMIT',
        #     order_price: '1',  # null for 'MARKET' order
        #     order_quantity: '12',  # null for 'MARKET' order
        #     order_amount: null,  # NOT-null for 'MARKET' order
        #     client_order_id: '0'
        # }
        return self.extend(
            self.parse_order(response, market),
            {'type': type}
        )

    def cancel_order(self, id, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' cancelOrder() requires a symbol argument')
        self.load_markets()
        request = None
        clientOrderIdUnified = self.safe_string_2(params, 'clOrdID', 'clientOrderId')
        clientOrderIdExchangeSpecific = self.safe_string_2(params, 'client_order_id', clientOrderIdUnified)
        isByClientOrder = clientOrderIdExchangeSpecific is not None
        if isByClientOrder:
            request['client_order_id'] = clientOrderIdExchangeSpecific
            params = self.omit(params, ['clOrdID', 'clientOrderId', 'client_order_id'])
        else:
            request['order_id'] = id
        market = None
        if symbol is not None:
            market = self.market(symbol)
        request['symbol'] = market['id']
        marketType, query = self.handle_market_type_and_params('cancelOrder', market, params)
        method = self.get_supported_mapping(marketType, {
            'spot': 'v1PrivateDeleteOrder',
        })
        response = getattr(self, method)(self.extend(request, query))
        #
        # {success: True, status: 'CANCEL_SENT'}
        #
        extendParams = {'symbol': symbol}
        if isByClientOrder:
            extendParams['client_order_id'] = clientOrderIdExchangeSpecific
        else:
            extendParams['id'] = id
        return self.extend(self.parse_order(response), extendParams)

    def cancel_orders(self, ids, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' canelOrders() requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        marketType, query = self.handle_market_type_and_params('cancelOrders', market, params)
        method = self.get_supported_mapping(marketType, {
            'spot': 'v1PrivateDeleteOrders',
        })
        response = getattr(self, method)(self.extend(request, query))
        return response

    def fetch_order(self, id, symbol=None, params={}):
        self.load_markets()
        market = self.market(symbol) if (symbol is not None) else None
        request = {}
        marketType, query = self.handle_market_type_and_params('fetchOrder', market, params)
        clientOrderId = self.safe_string_2(params, 'clOrdID', 'clientOrderId')
        chosenSpotMethod = None
        if clientOrderId:
            chosenSpotMethod = 'v1PrivateGetClientOrderClientOrderId'
            request['client_order_id'] = clientOrderId
        else:
            chosenSpotMethod = 'v1PrivateGetOrderOid'
            request['oid'] = id
        method = self.get_supported_mapping(marketType, {
            'spot': chosenSpotMethod,
        })
        response = getattr(self, method)(self.extend(request, query))
        #
        # {
        #     success: True,
        #     symbol: 'SPOT_WOO_USDT',
        #     status: 'FILLED',  # FILLED, NEW
        #     side: 'BUY',
        #     created_time: '1641480933.000',
        #     order_id: '87541111',
        #     order_tag: 'default',
        #     price: '1',
        #     type: 'LIMIT',
        #     quantity: '12',
        #     amount: null,
        #     visible: '12',
        #     executed: '12',  # or any partial amount
        #     total_fee: '0.0024',
        #     fee_asset: 'WOO',
        #     client_order_id: null,
        #     average_executed_price: '1',
        #     Transactions: [
        #       {
        #         id: '99111647',
        #         symbol: 'SPOT_WOO_USDT',
        #         fee: '0.0024',
        #         side: 'BUY',
        #         executed_timestamp: '1641482113.084',
        #         order_id: '87541111',
        #         executed_price: '1',
        #         executed_quantity: '12',
        #         fee_asset: 'WOO',
        #         is_maker: '1'
        #       }
        #     ]
        # }
        #
        return self.parse_order(response)

    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {}
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        if since is not None:
            request['start_t'] = since
        marketType, query = self.handle_market_type_and_params('fetchOrders', market, params)
        method = self.get_supported_mapping(marketType, {
            'spot': 'v1PrivateGetOrders',
        })
        response = getattr(self, method)(self.extend(request, query))
        data = self.safe_value(response, 'rows')
        return self.parse_orders(data, market, since, limit, params)

    def parse_order(self, order, market=None):
        #
        # Possible input functions:
        # * createOrder
        # * cancelOrder
        # * fetchOrder
        # * fetchOrders
        # isFromFetchOrder = ('order_tag' in order); TO_DO
        timestamp = self.safe_timestamp_2(order, 'timestamp', 'created_time')
        orderId = self.safe_integer(order, 'order_id')
        clientOrderId = self.safe_timestamp(order, 'client_order_id')  # Somehow, self always returns 0 for limit order
        marketId = self.safe_string(order, 'symbol')
        market = self.safe_market(marketId, market)
        symbol = market['symbol']
        price = self.safe_string_2(order, 'order_price', 'price')
        amount = self.safe_string_2(order, 'order_quantity', 'quantity')  # This is base amount
        cost = self.safe_string_2(order, 'order_amount', 'amount')  # This is quote amount
        orderType = self.safe_string_lower_2(order, 'order_type', 'type')
        status = self.safe_value(order, 'status')
        side = self.safe_string_lower_2(order, 'side')
        filled = self.safe_value(order, 'executed')
        remaining = Precise.string_sub(cost, filled)
        fee = self.safe_value(order, 'total_fee')
        feeCurrency = self.safe_string(order, 'fee_asset')
        transactions = self.safe_value(order, 'Transactions')
        return self.safe_order({
            'id': orderId,
            'clientOrderId': clientOrderId,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'status': self.parse_order_status(status),
            'symbol': symbol,
            'type': orderType,
            'timeInForce': None,
            'postOnly': None,  # TO_DO
            'side': side,
            'price': price,
            'stopPrice': None,
            'average': None,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,  # TO_DO
            'cost': cost,
            'trades': transactions,
            'fee': {
                'cost': fee,
                'currency': feeCurrency,
            },
            'info': order,
        }, market)

    def parse_order_status(self, status):
        if status is not None:
            statuses = {
                'NEW': 'open',
                'FILLED': 'closed',
                'CANCEL_SENT': 'canceled',
                'CANCEL_ALL_SENT': 'canceled',
            }
            return self.safe_string(statuses, status, status)
        return status

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            limit = min(limit, 1000)
            request['max_level'] = limit
        marketType, query = self.handle_market_type_and_params('fetchOrderBook', market, params)
        method = self.get_supported_mapping(marketType, {
            'spot': 'v1PrivateGetOrderbookSymbol',
        })
        response = getattr(self, method)(self.extend(request, query))
        #
        # {
        #   success: True,
        #   timestamp: '1641562961192',
        #   asks: [
        #     {price: '0.921', quantity: '76.01'},
        #     {price: '0.933', quantity: '477.10'},
        #     ...
        #   ],
        #   bids: [
        #     {price: '0.940', quantity: '13502.47'},
        #     {price: '0.932', quantity: '43.91'},
        #     ...
        #   ]
        # }
        #
        timestamp = self.safe_integer(response, 'timestamp')
        return self.parse_order_book(response, symbol, timestamp, 'bids', 'asks', 'price', 'quantity')

    def fetch_ohlcv(self, symbol, timeframe='1h', since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'type': self.timeframes[timeframe],
        }
        if limit is not None:
            request['limit'] = min(limit, 1000)
        marketType, query = self.handle_market_type_and_params('fetchOHLCV', market, params)
        method = self.get_supported_mapping(marketType, {
            'spot': 'v1PrivateGetKline',
        })
        response = getattr(self, method)(self.extend(request, query))
        # {
        #     success: True,
        #     rows: [
        #       {
        #         open: '0.94238',
        #         close: '0.94271',
        #         low: '0.94238',
        #         high: '0.94296',
        #         volume: '73.55',
        #         amount: '69.32040520',
        #         symbol: 'SPOT_WOO_USDT',
        #         type: '1m',
        #         start_timestamp: '1641584700000',
        #         end_timestamp: '1641584760000'
        #       },
        #       {
        #         open: '0.94186',
        #         close: '0.94186',
        #         low: '0.94186',
        #         high: '0.94186',
        #         volume: '64.00',
        #         amount: '60.27904000',
        #         symbol: 'SPOT_WOO_USDT',
        #         type: '1m',
        #         start_timestamp: '1641584640000',
        #         end_timestamp: '1641584700000'
        #       },
        #       ...
        #     ]
        # }
        data = self.safe_value(response, 'rows', [])
        return self.parse_ohlcvs(data, market, timeframe, since, limit)

    def parse_ohlcv(self, ohlcv, market=None):
        # example response in fetchOHLCV
        return [
            self.safe_integer(ohlcv, 'start_timestamp'),
            self.safe_number(ohlcv, 'open'),
            self.safe_number(ohlcv, 'high'),
            self.safe_number(ohlcv, 'low'),
            self.safe_number(ohlcv, 'close'),
            self.safe_number(ohlcv, 'volume'),
        ]

    def fetch_order_trades(self, id, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        market = None
        if symbol is not None:
            market = self.market(symbol)
        request = {
            'oid': id,
        }
        marketType, query = self.handle_market_type_and_params('fetchOrderTrades', market, params)
        method = self.get_supported_mapping(marketType, {
            'spot': 'v1PrivateGetOrderOidTrades',
        })
        response = getattr(self, method)(self.extend(request, query))
        # {
        #     success: True,
        #     rows: [
        #       {
        #         id: '99111647',
        #         symbol: 'SPOT_WOO_USDT',
        #         fee: '0.0024',
        #         side: 'BUY',
        #         executed_timestamp: '1641482113.084',
        #         order_id: '87541111',
        #         order_tag: 'default',
        #         executed_price: '1',
        #         executed_quantity: '12',
        #         fee_asset: 'WOO',
        #         is_maker: '1'
        #       }
        #     ]
        # }
        trades = self.safe_value(response, 'rows', [])
        return self.parse_trades(trades, market, since, limit, params)

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {}
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        if since is not None:
            request['start_t'] = since
        marketType, query = self.handle_market_type_and_params('fetchMyTrades', market, params)
        method = self.get_supported_mapping(marketType, {
            'spot': 'v1PrivateGetClientTrades',
        })
        response = getattr(self, method)(self.extend(request, query))
        # {
        #     "success": True,
        #     "meta": {
        #         "records_per_page": 25,
        #         "current_page": 1
        #     },
        #     "rows": [
        #         {
        #             "id": 5,
        #             "symbol": "SPOT_BTC_USDT",
        #             "order_id": 211,
        #             "order_tag": "default",
        #             "executed_price": 10892.84,
        #             "executed_quantity": 0.002,
        #             "is_maker": 0,
        #             "side": "SELL",
        #             "fee": 0,
        #             "fee_asset": "USDT",
        #             "executed_timestamp": "1566264290.250"
        #         },
        #         ...
        #     ]
        # }
        trades = self.safe_value(response, 'rows', [])
        return self.parse_trades(trades, market, since, limit, params)

    def fetch_balance(self, params={}):
        self.load_markets()
        marketType, query = self.handle_market_type_and_params('fetchBalance', None, params)
        method = self.get_supported_mapping(marketType, {
            'spot': 'v2PrivateGetClientHolding',
        })
        response = getattr(self, method)(query)
        #
        # {
        #     holding: [
        #       {
        #         token: 'USDT',
        #         holding: '23.56',  # free balance
        #         frozen: '888.0',  # i.e. if in processing withdrawal
        #         interest: '0.0',
        #         outstanding_holding: '-56.7',  # self value is set(negative number) if there is an open limit order, and self is QUOTE currency of order
        #         pending_exposure: '333.45',  #  self value is set  (positive number) if there is an open limit order, and self is BASE currency of order
        #         opening_cost: '0.00000000',
        #         holding_cost: '0.00000000',
        #         realised_pnl: '0.00000000',
        #         settled_pnl: '0.00000000',
        #         fee_24_h: '0',
        #         settled_pnl_24_h: '0',
        #         updated_time: '1641370779'
        #       },
        #       ...
        #     ],
        #     success: True
        # }
        #
        return self.parse_balance(response)

    def parse_balance(self, response):
        result = {
            'info': response,
        }
        balances = self.safe_value(response, 'holding', [])
        for i in range(0, len(balances)):
            balance = balances[i]
            code = self.safe_currency_code(self.safe_string(balance, 'token'))
            account = self.account()
            account['total'] = self.safe_string(balance, 'holding')
            used = self.safe_string(balance, 'outstanding_holding')
            account['used'] = Precise.string_neg(used)
            result[code] = account
        return self.safe_balance(result)

    def fetch_deposit_address(self, code, params={}):
        # self method is TODO because of networks unification
        self.load_markets()
        currency = self.currency(code)
        networkCodeDefault = self.default_network_code_for_currency(code)
        networkCode = self.safe_value(params, 'network', networkCodeDefault)
        params = self.omit(params, 'network')
        networkAliases = self.safe_value(self.options, 'network-aliases', {})
        networkId = self.getKeyByValue(networkAliases, networkCode)
        codeForExchange = networkId + '_' + currency['code']
        request = {
            'token': codeForExchange,
        }
        marketType, query = self.handle_market_type_and_params('fetchDepositAddress', None, params)
        method = self.get_supported_mapping(marketType, {
            'spot': 'v1PrivateGetAssetDeposit',
        })
        response = getattr(self, method)(self.extend(request, query))
        # {
        #     success: True,
        #     address: '3Jmtjx5544T4smrit9Eroe4PCrRkpDeKjP',
        #     extra: ''
        # }
        tag = self.safe_string(response, 'extra')
        if tag == '':
            tag = None
        address = self.safe_string(response, 'address')
        self.check_address(address)
        return {
            'currency': code,
            'address': address,
            'tag': tag,
            'network': networkCode,
            'info': response,
        }

    def get_asset_history_rows(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {}
        currency = None
        if code is not None:
            currency = self.currency(code)
            request['balance_token'] = currency['id']
        if since is not None:
            request['start_t'] = since
        if limit is not None:
            request['pageSize'] = limit
        transactionType = self.safe_string(params, 'type')
        params = self.omit(params, 'type')
        if transactionType is not None:
            request['type'] = transactionType
        response = self.v1PrivateGetAssetHistory(self.extend(request, params))
        # {
        #     rows: [
        #       {
        #         id: '22010508193900165',
        #         token: 'TRON_USDT',
        #         extra: '',
        #         amount: '13.75848500',
        #         status: 'COMPLETED',
        #         account: null,
        #         description: null,
        #         user_id: '42222',
        #         application_id: '6ad2b303-f354-45c0-8105-9f5f19d0e335',
        #         external_id: '220105081900134',
        #         target_address: 'TXnyFSnAYad3YCaqtwMw9jvXKkeU39NLnK',
        #         source_address: 'TYDzsYUEpvnYmQk4zGP9sWWcTEd2MiAtW6',
        #         type: 'BALANCE',
        #         token_side: 'DEPOSIT',
        #         tx_id: '35b0004022f6b3ad07f39a0b7af199f6b258c2c3e2c7cdc93c67efa74fd625ee',
        #         fee_token: '',
        #         fee_amount: '0.00000000',
        #         created_time: '1641370779.442',
        #         updated_time: '1641370779.465',
        #         is_new_target_address: null,
        #         confirmed_number: '29',
        #         confirming_threshold: '27',
        #         audit_tag: '1',
        #         audit_result: '0',
        #         balance_token: null,  # TODO -write to support, that self seems broken. here should be the token id
        #         network_name: null  # TODO -write to support, that self seems broken. here should be the network id
        #       }
        #     ],
        #     meta: {total: '1', records_per_page: '25', current_page: '1'},
        #     success: True
        # }
        return [currency, self.safe_value(response, 'rows', {})]

    def fetch_ledger(self, code=None, since=None, limit=None, params={}):
        currency, rows = self.get_asset_history_rows(code, since, limit, params)
        return self.parse_ledger(rows, currency, since, limit, params)

    def parse_ledger_entry(self, item, currency=None):
        networkizedCode = self.safe_string(item, 'token')
        currencyDefined = self.get_currency_from_chaincode(networkizedCode, currency)
        code = currencyDefined['code']
        amount = self.safe_number(item, 'amount')
        side = self.safe_number(item, 'token_side')
        direction = 'in' if (side == 'DEPOSIT') else 'out'
        timestamp = self.safe_timestamp(item, 'created_time')
        fee = self.parse_token_and_fee_temp(item, 'fee_token', 'fee_amount')
        return {
            'id': self.safe_string(item, 'id'),
            'currency': code,
            'account': self.safe_string(item, 'account'),
            'referenceAccount': None,
            'referenceId': self.safe_string(item, 'tx_id'),
            'status': self.parse_transaction_status(item, 'status'),
            'amount': amount,
            'before': None,
            'after': None,
            'fee': fee,
            'direction': direction,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'type': self.parse_ledger_entry_type(self.safe_string(item, 'type')),
            'info': item,
        }

    def parse_ledger_entry_type(self, type):
        types = {
            'BALANCE': 'transaction',  # Funds moved in/out wallet
            'COLLATERAL': 'transfer',  # Funds moved between portfolios
        }
        return self.safe_string(types, type, type)

    def get_currency_from_chaincode(self, networkizedCode, currency):
        if currency is not None:
            return currency
        else:
            parts = networkizedCode.split('_')
            partsLength = len(parts)
            firstPart = self.safe_string(parts, 0)
            currencyId = self.safe_string(parts, 1, firstPart)
            if partsLength > 2:
                currencyId += '_' + self.safe_string(parts, 2)
            currency = self.safe_currency(currencyId)
        return currency

    def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        request = {
            'token_side': 'DEPOSIT',
        }
        return self.fetch_transactions(code, since, limit, self.extend(request, params))

    def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        request = {
            'token_side': 'WITHDRAW',
        }
        return self.fetch_transactions(code, since, limit, self.extend(request, params))

    def fetch_transactions(self, code=None, since=None, limit=None, params={}):
        request = {
            'type': 'BALANCE',
        }
        currency, rows = self.get_asset_history_rows(code, since, limit, self.extend(request, params))
        return self.parse_transactions(rows, currency, since, limit, params)

    def parse_transaction(self, transaction, currency=None):
        # example in fetchLedger
        networkizedCode = self.safe_string(transaction, 'token')
        currencyDefined = self.get_currency_from_chaincode(networkizedCode, currency)
        code = currencyDefined['code']
        movementDirection = self.safe_string_lower(transaction, 'token_side')
        if movementDirection == 'withdraw':
            movementDirection = 'withdrawal'
        fee = self.parse_token_and_fee_temp(transaction, 'fee_token', 'fee_amount')
        fee['rate'] = None
        addressTo = self.safe_string(transaction, 'target_address')
        addressFrom = self.safe_string(transaction, 'source_address')
        timestamp = self.safe_timestamp(transaction, 'created_time')
        return {
            'id': self.safe_string(transaction, 'id'),
            'txid': self.safe_string(transaction, 'tx_id'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'address': None,
            'addressFrom': addressFrom,
            'addressTo': addressTo,
            'tag': self.safe_string(transaction, 'extra'),
            'type': movementDirection,
            'amount': self.safe_number(transaction, 'amount'),
            'currency': code,
            'status': self.parse_transaction_status(self.safe_string(transaction, 'status')),
            'updated': self.safe_timestamp(transaction, 'updated_time'),
            'fee': fee,
            'info': transaction,
        }

    def parse_transaction_status(self, status):
        statuses = {
            'NEW': 'pending',
            'CONFIRMING': 'pending',
            'PROCESSING': 'pending',
            'COMPLETED': 'ok',
            'CANCELED': 'canceled',
        }
        return self.safe_string(statuses, status, status)

    def transfer(self, code, amount, fromAccount, toAccount, params={}):
        self.load_markets()
        currency = self.currency(code)
        request = {
            'token': currency['id'],
            'amount': self.parse_number(amount),
            'from_application_id': fromAccount,
            'to_application_id': toAccount,
        }
        response = self.v1PrivatePostAssetMainSubTransfer(self.extend(request, params))
        #
        #     {
        #         "success": True,
        #         "id": 200
        #     }
        #
        transfer = self.parse_transfer(response, currency)
        transferOptions = self.safe_value(self.options, 'transfer', {})
        fillResponseFromRequest = self.safe_value(transferOptions, 'fillResponseFromRequest', True)
        if fillResponseFromRequest:
            transfer['amount'] = amount
            transfer['fromAccount'] = fromAccount
            transfer['toAccount'] = toAccount
        return transfer

    def fetch_transfers(self, code=None, since=None, limit=None, params={}):
        request = {
            'type': 'COLLATERAL',
        }
        currency, rows = self.get_asset_history_rows(code, since, limit, self.extend(request, params))
        return self.parse_transfers(rows, currency, since, limit, params)

    def parse_transfer(self, transfer, currency=None):
        #
        #    getAssetHistoryRows
        #        {
        #            "created_time": "1579399877.041",  # Unix epoch time in seconds
        #            "updated_time": "1579399877.041",  # Unix epoch time in seconds
        #            "id": "202029292829292",
        #            "external_id": "202029292829292",
        #            "application_id": null,
        #            "token": "ETH",
        #            "target_address": "0x31d64B3230f8baDD91dE1710A65DF536aF8f7cDa",
        #            "source_address": "0x70fd25717f769c7f9a46b319f0f9103c0d887af0",
        #            "extra": "",
        #            "type": "BALANCE",
        #            "token_side": "DEPOSIT",
        #            "amount": 1000,
        #            "tx_id": "0x8a74c517bc104c8ebad0c3c3f64b1f302ed5f8bca598ae4459c63419038106b6",
        #            "fee_token": null,
        #            "fee_amount": null,
        #            "status": "CONFIRMING"
        #        }
        #
        #    v1PrivatePostAssetMainSubTransfer
        #        {
        #            "success": True,
        #            "id": 200
        #        }
        #
        networkizedCode = self.safe_string(transfer, 'token')
        currencyDefined = self.get_currency_from_chaincode(networkizedCode, currency)
        code = currencyDefined['code']
        movementDirection = self.safe_string_lower(transfer, 'token_side')
        if movementDirection == 'withdraw':
            movementDirection = 'withdrawal'
        fromAccount = None
        toAccount = None
        if movementDirection == 'withdraw':
            fromAccount = None
            toAccount = 'spot'
        elif movementDirection == 'deposit':
            fromAccount = 'spot'
            toAccount = None
        timestamp = self.safe_timestamp(transfer, 'created_time')
        success = self.safe_value(transfer, 'success')
        status = None
        if success is not None:
            status = 'ok' if success else 'failed'
        return {
            'id': self.safe_string(transfer, 'id'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'currency': code,
            'amount': self.safe_number(transfer, 'amount'),
            'fromAccount': fromAccount,
            'toAccount': toAccount,
            'status': self.parse_transfer_status(self.safe_string(transfer, 'status', status)),
            'info': transfer,
        }

    def parse_transfer_status(self, status):
        statuses = {
            'NEW': 'pending',
            'CONFIRMING': 'pending',
            'PROCESSING': 'pending',
            'COMPLETED': 'ok',
            'CANCELED': 'canceled',
        }
        return self.safe_string(statuses, status, status)

    def nonce(self):
        return self.milliseconds()

    def sign(self, path, section='public', method='GET', params={}, headers=None, body=None):
        version = section[0]
        access = section[1]
        url = self.implode_hostname(self.urls['api'][access])
        url += '/' + version + '/'
        path = self.implode_params(path, params)
        params = self.omit(params, self.extract_params(path))
        params = self.keysort(params)
        if access == 'public':
            url += access + '/' + path
            if params:
                url += '?' + self.urlencode(params)
        else:
            self.check_required_credentials()
            url += path
            ts = str(self.nonce())
            auth = self.urlencode(params)
            if method == 'POST' or method == 'DELETE':
                body = auth
            else:
                url += '?' + auth
            auth += '|' + ts
            signature = self.hmac(self.encode(auth), self.encode(self.secret), hashlib.sha256)
            headers = {
                'x-api-key': self.apiKey,
                'x-api-signature': signature,
                'x-api-timestamp': ts,
                'Content-Type': 'application/x-www-form-urlencoded',
            }
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if not response:
            return  # fallback to default error handler
        #
        #     400 Bad Request {"success":false,"code":-1012,"message":"Amount is required for buy market orders when margin disabled."}
        #
        success = self.safe_value(response, 'success')
        errorCode = self.safe_string(response, 'code')
        if not success:
            feedback = self.id + ' ' + self.json(response)
            self.throw_broadly_matched_exception(self.exceptions['broad'], body, feedback)
            self.throw_exactly_matched_exception(self.exceptions['exact'], errorCode, feedback)

    def default_network_code_for_currency(self, code):
        # at first, try to find if user or exchange has defined default networks for the specific currency
        defaultNetworkCodeForCurrencies = self.safe_value(self.options, 'defaultNetworkCodeForCurrencies')
        if defaultNetworkCodeForCurrencies is not None:
            defaultNetworkCode = self.safe_string_upper(defaultNetworkCodeForCurrencies, code)
            if defaultNetworkCode is not None:
                return defaultNetworkCode
        # if not found by above 'defaultNetworkCodeForCurrencies' for specific currency, then try with `defaultNetworkCodePriorities`
        currencyItem = self.currency(code)
        networks = currencyItem['networks']
        defaultNetworkCodePriorities = self.safe_value(self.options, 'defaultNetworkCodePriorities')
        if defaultNetworkCodePriorities is not None:
            # itterate according to priority networks
            networksKeys = list(networks.keys())
            networksKeysLength = len(networksKeys)
            if networksKeysLength > 0:
                for i in range(0, len(defaultNetworkCodePriorities)):
                    networkCode = defaultNetworkCodePriorities[i]
                    if networkCode in networks:
                        return networkCode
        # if it was not returned according to above options, then return the first network of currency
        networkKeys = list(networks.keys())
        return self.safe_value(networkKeys, 0)
